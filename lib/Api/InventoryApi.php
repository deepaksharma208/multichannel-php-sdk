<?php
/**
 * InventoryApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * ShiprocketAPI
 *
 * Welcome to ShipRocket’s API Documentation. Get a clear understanding of all the sections and codes that are used in ShipRocket’s API. ShipRocket API uses the JSON syntax.     First you need to register with ShipRocket and create an account. Simply click on this [link](https://app.shiprocket.in/register) to complete the simple sign up process.    Please note that to utilise the ShipRocket API's, you need to [upgrade](https://app.shiprocket.in/billing-plan-details) your plan to Advance or Pro. To get access to use the API's, you need to call to +91-9266623006 our customer care or send a mail to srs@kartrocket.com, stating that you would like to use ShipRocket Open API's. After that you will have to provide an alternate email id which will be used for the ShipRocket API.
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.3.1
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * InventoryApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class InventoryApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getInventories
     *
     * Get Details of orders with inventories
     *
     * @param  int $page The page number which is to be displayed (required)
     * @param  int $per_page The total number of products in each page in an integer format (optional)
     * @param  string $sort Whether to arrange the items in ascending or descending order (optional)
     * @param  string $sort_by Allows to choose the value field by which the items will be sorted. Could be sorted by id, by sku, time created etc. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\GetInventoriesResponse
     */
    public function getInventories($page, $per_page = null, $sort = null, $sort_by = null)
    {
        list($response) = $this->getInventoriesWithHttpInfo($page, $per_page, $sort, $sort_by);
        return $response;
    }

    /**
     * Operation getInventoriesWithHttpInfo
     *
     * Get Details of orders with inventories
     *
     * @param  int $page The page number which is to be displayed (required)
     * @param  int $per_page The total number of products in each page in an integer format (optional)
     * @param  string $sort Whether to arrange the items in ascending or descending order (optional)
     * @param  string $sort_by Allows to choose the value field by which the items will be sorted. Could be sorted by id, by sku, time created etc. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\GetInventoriesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInventoriesWithHttpInfo($page, $per_page = null, $sort = null, $sort_by = null)
    {
        $returnType = '\Swagger\Client\Model\GetInventoriesResponse';
        $request = $this->getInventoriesRequest($page, $per_page, $sort, $sort_by);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\GetInventoriesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInventoriesAsync
     *
     * Get Details of orders with inventories
     *
     * @param  int $page The page number which is to be displayed (required)
     * @param  int $per_page The total number of products in each page in an integer format (optional)
     * @param  string $sort Whether to arrange the items in ascending or descending order (optional)
     * @param  string $sort_by Allows to choose the value field by which the items will be sorted. Could be sorted by id, by sku, time created etc. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInventoriesAsync($page, $per_page = null, $sort = null, $sort_by = null)
    {
        return $this->getInventoriesAsyncWithHttpInfo($page, $per_page, $sort, $sort_by)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInventoriesAsyncWithHttpInfo
     *
     * Get Details of orders with inventories
     *
     * @param  int $page The page number which is to be displayed (required)
     * @param  int $per_page The total number of products in each page in an integer format (optional)
     * @param  string $sort Whether to arrange the items in ascending or descending order (optional)
     * @param  string $sort_by Allows to choose the value field by which the items will be sorted. Could be sorted by id, by sku, time created etc. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInventoriesAsyncWithHttpInfo($page, $per_page = null, $sort = null, $sort_by = null)
    {
        $returnType = '\Swagger\Client\Model\GetInventoriesResponse';
        $request = $this->getInventoriesRequest($page, $per_page, $sort, $sort_by);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInventories'
     *
     * @param  int $page The page number which is to be displayed (required)
     * @param  int $per_page The total number of products in each page in an integer format (optional)
     * @param  string $sort Whether to arrange the items in ascending or descending order (optional)
     * @param  string $sort_by Allows to choose the value field by which the items will be sorted. Could be sorted by id, by sku, time created etc. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getInventoriesRequest($page, $per_page = null, $sort = null, $sort_by = null)
    {
        // verify the required parameter 'page' is set
        if ($page === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $page when calling getInventories'
            );
        }

        $resourcePath = '/v1/external/inventory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['per_page'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($sort_by !== null) {
            $queryParams['sort_by'] = ObjectSerializer::toQueryValue($sort_by);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateInventory
     *
     * Update Inventory
     *
     * @param  int $id You have to pass the product id of the inventory which is to be updated (required)
     * @param  int $quantity The specific number which needs to be changed (required)
     * @param  string $action Added &#x3D; The number is added to the inventory Replace &#x3D; The original number is replaced by the specific number Remove &#x3D; The specific number is deducted from the opening number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\UpdateInventoryResponse
     */
    public function updateInventory($id, $quantity, $action)
    {
        list($response) = $this->updateInventoryWithHttpInfo($id, $quantity, $action);
        return $response;
    }

    /**
     * Operation updateInventoryWithHttpInfo
     *
     * Update Inventory
     *
     * @param  int $id You have to pass the product id of the inventory which is to be updated (required)
     * @param  int $quantity The specific number which needs to be changed (required)
     * @param  string $action Added &#x3D; The number is added to the inventory Replace &#x3D; The original number is replaced by the specific number Remove &#x3D; The specific number is deducted from the opening number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\UpdateInventoryResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateInventoryWithHttpInfo($id, $quantity, $action)
    {
        $returnType = '\Swagger\Client\Model\UpdateInventoryResponse';
        $request = $this->updateInventoryRequest($id, $quantity, $action);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\UpdateInventoryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateInventoryAsync
     *
     * Update Inventory
     *
     * @param  int $id You have to pass the product id of the inventory which is to be updated (required)
     * @param  int $quantity The specific number which needs to be changed (required)
     * @param  string $action Added &#x3D; The number is added to the inventory Replace &#x3D; The original number is replaced by the specific number Remove &#x3D; The specific number is deducted from the opening number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateInventoryAsync($id, $quantity, $action)
    {
        return $this->updateInventoryAsyncWithHttpInfo($id, $quantity, $action)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateInventoryAsyncWithHttpInfo
     *
     * Update Inventory
     *
     * @param  int $id You have to pass the product id of the inventory which is to be updated (required)
     * @param  int $quantity The specific number which needs to be changed (required)
     * @param  string $action Added &#x3D; The number is added to the inventory Replace &#x3D; The original number is replaced by the specific number Remove &#x3D; The specific number is deducted from the opening number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateInventoryAsyncWithHttpInfo($id, $quantity, $action)
    {
        $returnType = '\Swagger\Client\Model\UpdateInventoryResponse';
        $request = $this->updateInventoryRequest($id, $quantity, $action);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateInventory'
     *
     * @param  int $id You have to pass the product id of the inventory which is to be updated (required)
     * @param  int $quantity The specific number which needs to be changed (required)
     * @param  string $action Added &#x3D; The number is added to the inventory Replace &#x3D; The original number is replaced by the specific number Remove &#x3D; The specific number is deducted from the opening number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateInventoryRequest($id, $quantity, $action)
    {
        // verify the required parameter 'id' is set
        if ($id === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateInventory'
            );
        }
        // verify the required parameter 'quantity' is set
        if ($quantity === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $quantity when calling updateInventory'
            );
        }
        // verify the required parameter 'action' is set
        if ($action === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $action when calling updateInventory'
            );
        }

        $resourcePath = '/v1/external/inventory/{id}/update';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($quantity !== null) {
            $queryParams['quantity'] = ObjectSerializer::toQueryValue($quantity);
        }
        // query params
        if ($action !== null) {
            $queryParams['action'] = ObjectSerializer::toQueryValue($action);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
